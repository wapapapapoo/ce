eq := (a: i64, b: i64): i32 => !pure { a; };

eq(1);

// 基础绑定：字面量
x := 42;
y := true;
z := "hello";

add := (a: arr!(i32, ...)) => {
    loop!((pass: (i: i32, sum: i32), keepon: bool) => {
        ((+(i, 1), +(sum, a(i))), <(i, len(a)));
    }, (0, 0))(sum);
};

nihao := (): unit => {

    // 非 indexed list
    nums := (1, 2, 3,);

    // indexed list（作为 record / 参数）
    point := (x: 10, y: 20);

    // mixed list（你 grammar 允许）
    mixed := (1, a: 2, 3, b: 4);

    // 简单函数，无返回类型标注，无 annotation
    id := (v: T) => {
        v
    };

};

// 带返回类型（atom_expression）
// 注意：复杂类型必须加括号
add := (a: i32, b: i32): i32 => {
    a
};

// 带 annotation（atom_expression）
// annotation 本身是表达式，但这里用 atom
mul := (a: i32, b: i32): i32 => pure inline {
        a
    };

// 函数作为值，嵌套函数
makeAdder := (x: i32): () => { i32 } => {
    (y: i32): i32 => {
        x
    }
}; // 显然它是错的，但是parser允许

// 直接调用（convenient_call）
r1 := add(1, 2);

// 调用函数值
r2 := (makeAdder(10))(32);

// function literal 直接作为 callee
r3 := ((x: i32): i32 => { x })(5);

// common_call 形式
r4 := [add, (3, 4)];

// list 作为普通表达式参与计算
useList := (lst: (i32, i32)): i32 => {
    lst
};

awa:=-100;

args := *((arg: i32), 5);
fn := args: i32 => !pure { get!(arg, 0) };

[awa, pwp];

[awa, (1, 2)];

type := (chrs: ...);
print := (len: i32, str: type) => !effect { };

add := (a: i32, b: i32): i32 => {
    +(a, b);
};

awa := add(2, 2);
